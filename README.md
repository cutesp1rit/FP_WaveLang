# Wave Language - Функциональный язык программирования

## О проекте

**Wave** - это минималистичный функциональный язык программирования, в котором всё представлено как преобразования через волны (`~`). Язык прост в синтаксисе, но мощен в функциональности.

Проект был разработан в рамках лабораторной работы по функциональному программированию. Основная цель - создать собственный функциональный язык программирования с уникальным синтаксисом и полной реализацией интерпретатора.

## Особенности языка

### Основные принципы:
1. **Всё есть преобразование** - функции это волны, преобразующие входные данные.
2. **Минимум синтаксиса** - только `~`, `=`, `()`, `[]`, и базовые операторы.
3. **Паттерн-матчинг** через условия.
4. **Композиция** естественная через цепочки волн.

### Примеры синтаксиса:
```wave
// Определение функции
double ~ x ~ x * 2

// Факториал с паттерн-матчингом
factorial ~ n
  n = 0 ~ 1
  _ ~ n * factorial(n - 1)

// Композиция функций
3 ~ double ~ addOne

// Работа со списками
[1, 2, 3] ~ double
```

## Уникальные особенности Wave (планируются к реализации)

1. **Операторы волновой композиции** (этап 2-3):
   - `~~` - строгая композиция.
   - `~>` - ленивая композиция.
   - `|~` - параллельная композиция.

2. **Метапрограммирование** (этап 2):
   ```wave
   defun ~ name ~ params ~ body ~
     name ~ params ~ body
   ```

3. **Визуальный отладчик с волнами** (этап 3, бонус):
   - Показывает поток данных через волны.
   - Анимация вычислений.

## Реализованные функции

- ✅ Определение функций (`имя ~ параметр ~ тело`)
- ✅ Паттерн-матчинг (`имя ~ параметр` с условиями)
- ✅ Арифметические операции (`+`, `-`, `*`, `/`)
- ✅ Композиция функций (`значение ~ функция1 ~ функция2`)
- ✅ Списки (`[1,2,3]`)
- ✅ Операции со списками (`[элементы] ~ операции`)

Полная спецификация синтаксиса доступна в [docs/SYNTAX.md](docs/SYNTAX.md).

## План разработки

Проект разрабатывается в три этапа согласно плану команды:

### Этап 1: Парсер и AST (Дни 1-3) - ЗАВЕРШЕН
**Участник 1 (Максимов Тимофей Степанович)**

**Задачи:**
1. Разработать спецификацию синтаксиса.
2. Создать AST (Abstract Syntax Tree).
3. Реализовать лексер и парсер.
4. Написать тесты для парсера.

**Результаты:**
- ✅ Спецификация синтаксиса разработана и задокументирована
- ✅ AST создан в файле [src/WaveLanguage/AST.fs](src/WaveLanguage/AST.fs)
- ✅ Лексер реализован в файле [src/WaveLanguage/Lexer.fs](src/WaveLanguage/Lexer.fs)
- ✅ Парсер реализован в файле [src/WaveLanguage/Parser.fs](src/WaveLanguage/Parser.fs)
- ✅ Добавлена поддержка всех запланированных функций языка
- ✅ Написаны тесты для парсера в файле [tests/ParserTests.fs](tests/ParserTests.fs)
- ✅ Созданы примеры программ для демонстрации работы

**Контрольные точки:**
- ✅ Все тесты парсера проходят
- ✅ AST корректно строится для всех конструкций

### Этап 2: Интерпретатор, встроенные функции и REPL (Дни 4-6) — ЗАВЕРШЕН  
**Участник 2 (Попов Фома Алексеевич)**

Задачи:  
1. Реализовать вычислитель выражений (evaluator) — интерпретацию AST-программ на Wave.  
2. Реализовать поддержку замыканий, let-функций, рекурсии, паттерн-матчинга, списков.  
3. Реализовать встроенные функции (`inc`, dec, square, head, tail, sum и др.), автоприменение функций к спискам (“map”).  
4. Написать REPL (интерактивная среда с вводом выражений).  
5. Интеграция unit-тестов (NUnit) для вычисления (арифметика, рекурсии, композиция, списки, встроенные функции).

**Результаты:** 
- ✅ Реализован вычислитель (src/WaveLanguage/Evaluator.fs), поддерживающий все основные конструкции языка Wave — числа, списки, пары, функции, композицию, лямбды, let, паттерн-матчинг, замыкания.
- ✅ Обеспечена поддержка рекурсивных определений (`let rec`) и их правильная работа с окружением (factorial, map и др.).
- ✅ Встроенные функции реализованы (src/WaveLanguage/Builtin.fs) — арифметика, работа со списками, ввод-вывод (`print`, inc, sum, и т.д.).
- ✅ Автоматическое применение пользовательских/встроенных функций к элементам списка (`[1,2,3] ~ square` → `[1,4,9]`).
- ✅ Интерактивный REPL (src/WaveLanguage/REPL.fs) с поддержкой пошагового исполнения выражений в живом окружении.
- ✅ Реализованы и проходят юнит-тесты вычислений (арифметика, рекурсии, списки, composition) в [tests/EvaluatorTests.fs](tests/EvaluatorTests.fs).

**Контрольные точки:** 
- ✅ Запуск любого скрипта из [examples/](examples/) выдаёт корректный результат (см. [comprehensive.wave](examples/comprehensive.wave), [factorial.wave](examples/factorial.wave) и др.).
- ✅ Все тесты (в том числе для нестандартных случаев — map, рекурсия, встроенные функции) проходят.
- ✅ REPL корректно выполняет все конструкции языка.

### Этап 3: Примеры, документация и визуальный отладчик (Дни 7-9) - В РАЗРАБОТКЕ
**Участник 3**

**Задачи:**
1. Написать showcase-примеры (факториал, Фибоначчи, сортировки).
2. Создать полную документацию.
3. Настроить GitHub Pages.
4. Реализовать визуальный отладчик:
   - Графическое представление цепочки преобразований.
   - Лог выполнения с подсветкой текущего шага.
   - Возможность "поставить на паузу" и посмотреть состояние данных.

**Контрольные точки:**
- Примеры программ запускаются.
- Документация полная и понятная.
- Визуальный отладчик работает и отображает шаги выполнения.

## Автор

**Максимов Тимофей Степанович** - Участник 1 (Парсер и AST)

### Что реализовано:
1. Разработал спецификацию синтаксиса языка
2. Создал AST (Abstract Syntax Tree) в файле [src/WaveLanguage/AST.fs](src/WaveLanguage/AST.fs)
3. Реализовал лексер в файле [src/WaveLanguage/Lexer.fs](src/WaveLanguage/Lexer.fs)
4. Реализовал парсер в файле [src/WaveLanguage/Parser.fs](src/WaveLanguage/Parser.fs)
5. Добавил поддержку:
   - Определения функций
   - Паттерн-матчинга
   - Арифметических операций
   - Композиции функций
   - Списков и операций над ними
6. Написал тесты для парсера в файле [tests/ParserTests.fs](tests/ParserTests.fs)
7. Создал примеры программ:
   - [examples/simple.wave](examples/simple.wave) - простое определение функции
   - [examples/factorial.wave](examples/factorial.wave) - факториал с паттерн-матчингом
   - [examples/list.wave](examples/list.wave) - работа со списками
   - [examples/composition.wave](examples/composition.wave) - композиция функций
   - [examples/list_operations.wave](examples/list_operations.wave) - операции со списками
   - [examples/comprehensive.wave](examples/comprehensive.wave) - комплексный пример

**Попов Фома Алексеевич** - Участник 2 (Интерпретатор, встроенные функции и REPL)

**Что реализовано:**
1. Реализация вычислителя выражений (src/WaveLanguage/Evaluator.fs)
2. Механизм замыканий, рекурсивных функций (`let rec`) и scope передается между выражениями (factorial и подобные вызовы работают корректно)
3. Встроенные функции (`inc`, dec, square, head, tail, `sum`) через Value.BuiltinFun (src/WaveLanguage/Builtin.fs), обработка ошибок типов
4. Корректная обработка автоматического map при применении функций к спискам
5. REPL — файл [src/WaveLanguage/REPL.fs](src/WaveLanguage/REPL.fs), поддержка Expression→Result, состояние окружения между вводами
6. Покрытие логикой и тестами арифметических и композиционных выражений, рекурсивных определений, списков, встроенных функций ([tests/EvaluatorTests.fs](tests/EvaluatorTests.fs))

### Инструменты разработки:
В процессе разработки использовались современные инструменты программирования, включая помощники на основе искусственного интеллекта для совместной проработки архитектурных решений и написания тестов.

## Запуск проекта

### Требования
- .NET 9.0 SDK

### Сборка проекта
```bash
dotnet build
```

### Запуск примеров
```bash
# Запуск простого примера
dotnet run --project src/WaveLanguage/WaveLanguage.fsproj examples/simple.wave

# Запуск факториала
dotnet run --project src/WaveLanguage/WaveLanguage.fsproj examples/factorial.wave

# Запуск комплексного примера
dotnet run --project src/WaveLanguage/WaveLanguage.fsproj examples/comprehensive.wave
```

### Запуск REPL
```bash
dotnet run --project src/WaveLanguage/WaveLanguage.fsproj
```

### Запуск тестов
```bash
dotnet test tests/WaveLanguage.Tests.fsproj
```

## Структура проекта

```
├── src/WaveLanguage/          # Исходный код языка
│   ├── AST.fs                 # Абстрактное синтаксическое дерево (AST)
│   ├── Lexer.fs               # Лексер (токенизатор)
│   ├── Parser.fs              # Парсер (разбор токенов в AST)
│   ├── Value.fs               # Типы значений (Value) и окружения (Env)
│   ├── Builtin.fs             # Реализация встроенных функций языка
│   ├── Evaluation.fs          # Вычислитель выражений (интерпретатор, evaluator)
│   ├── REPL.fs                # REPL — интерактивная среда (Read-Eval-Print-Loop)
│   └── Program.fs             # Точка входа (запуск с файлом или REPL)
├── tests/                     # Модульные тесты
│   ├── ParserTests.fs         # Тесты для парсера
│   ├── EvaluatorTests.fs      # Тесты для вычислений (интерпретатора)
│   └── WaveLanguage.Tests.fsproj  # Проект тестов (.NET)
├── examples/                  # Примеры программ на Wave
│   ├── simple.wave            # Простой пример
│   ├── factorial.wave         # Реализация факториала
│   ├── list.wave              # Пример работы со списками
│   ├── composition.wave       # Композиция функций
│   ├── list_operations.wave   # Операции со списками
│   └── comprehensive.wave     # Комплексный пример (всё вместе)
├── docs/                      # Документация
│   └── SYNTAX.md              # Полная спецификация синтаксиса языка
└── ASSIGNMENT.md              # Исходное лабораторное задание
```

## Лицензия

Этот проект был создан в образовательных целях в рамках курса по функциональному программированию.