# Язык программирования Wave 

**Wave** — функциональный язык программирования, вдохновленный композицией функций и "волновыми" преобразованиями данных. Язык реализован на F# и предоставляет простой, но мощный синтаксис для работы с функциями, списками и паттерн-матчингом.

## Содержание

- [Введение](#введение)
- [Установка и запуск](#установка-и-запуск)
- [Основные концепции](#основные-концепции)
- [Синтаксис языка](#синтаксис-языка)
- [Примеры программ](#примеры-программ)
- [Встроенные функции](#встроенные-функции)
- [Расширенные возможности](#расширенные-возможности)

---

## Введение

Wave — это функциональный язык, построенный на следующих принципах:

- **Композиция функций** через оператор `~` ("волна")
- **Паттерн-матчинг** для определения функций
- **Автоматическое применение (map)** функций к спискам
- **Рекурсия** как основной механизм итерации
- **Замыкания** и функции высшего порядка

### Философия языка

Название "Wave" отражает идею преобразования данных как волны, проходящей через серию функций. Оператор `~` визуально напоминает волну и служит универсальным инструментом для определения и композиции функций.

---

## Установка и запуск

### Требования

- .NET 9.0 SDK или выше
- F# compiler

### Сборка проекта

```bash
dotnet build
```

### Запуск программы

**Выполнение файла:**
```bash
dotnet run --project src/WaveLanguage/WaveLanguage.fsproj examples/factorial.wave
```

**Режим отладки (показывает токены и AST):**
```bash
dotnet run --project src/WaveLanguage/WaveLanguage.fsproj examples/factorial.wave --debug
```

**Интерактивный REPL:**
```bash
dotnet run --project src/WaveLanguage/WaveLanguage.fsproj
```

---

## Основные концепции

### 1. Определение функций

В Wave функции определяются с помощью оператора `~`:

```wave
имя ~ параметр ~ тело
```

**Пример:**
```wave
double ~ x ~ x * 2
```

Это определяет функцию `double`, которая принимает параметр `x` и возвращает `x * 2`.

### 2. Вызов функций

Функции вызываются с помощью круглых скобок:

```wave
double(5)  // Результат: 10
```

### 3. Композиция функций

Оператор `~` также используется для композиции функций:

```wave
5 ~ double ~ addOne
```

Это эквивалентно `addOne(double(5))`.

### 4. Паттерн-матчинг

Функции могут иметь несколько определений с разными паттернами:

```wave
factorial ~ n
  n = 0 ~ 1
  _ ~ n * factorial(n - 1)
```

Паттерны проверяются сверху вниз. `_` означает "любое значение".

---

## Синтаксис языка

### Числа

```wave
42
3.14
-17
```

### Идентификаторы

```wave
x
factorial
my_function
```

### Арифметические операции

```wave
2 + 3       // Сложение
10 - 4      // Вычитание
5 * 6       // Умножение
20 / 4      // Деление
```

**Приоритет операций:** `*` и `/` имеют более высокий приоритет, чем `+` и `-`.

### Списки

**Создание списков:**
```wave
[]              // Пустой список
[1, 2, 3]       // Список чисел
[x, y, z]       // Список переменных
```

**Операции со списками:**
```wave
head([1, 2, 3])     // Первый элемент: 1
tail([1, 2, 3])     // Хвост списка: [2, 3]
sum([1, 2, 3])      // Сумма элементов: 6
```

### Композиция

#### Базовая композиция (`~`)

```wave
3 ~ double ~ addOne  // 7
```

#### Строгая композиция (`~~`)

Вычисляет все элементы немедленно:

```wave
3 ~~ double ~~ addOne  // 7
```

#### Ленивая композиция (`~>`)

Откладывает вычисления до момента использования:

```wave
3 ~> double ~> addOne  // 7 (вычисляется при необходимости)
```

#### Параллельная композиция (`|~`)

Применяет функции поэлементно к спискам:

```wave
[1, 2, 3] |~ double |~ addOne  // [3, 5, 7]
```

### Паттерн-матчинг

**Синтаксис:**
```wave
function_name ~ parameter
  pattern1 ~ result1
  pattern2 ~ result2
  _ ~ default_result
```

**Пример:**
```wave
sign ~ n
  n > 0 ~ 1
  n = 0 ~ 0
  _ ~ -1
```

### Let-выражения

```wave
let x = 5 in x * 2  // Результат: 10
```

### Рекурсия

Функции могут вызывать сами себя:

```wave
factorial ~ n
  n = 0 ~ 1
  _ ~ n * factorial(n - 1)
```

---

## Примеры программ

### Пример 1: Факториал

```wave
factorial ~ n
  n = 0 ~ 1
  _ ~ n * factorial(n - 1)

factorial(5)  // Результат: 120
```

### Пример 2: Числа Фибоначчи

```wave
fib ~ n
  n = 0 ~ 0
  n = 1 ~ 1
  _ ~ fib(n - 1) + fib(n - 2)

fib(10)  // Результат: 55
```

### Пример 3: Работа со списками

```wave
double ~ x ~ x * 2
square ~ x ~ x * x

[1, 2, 3, 4, 5] ~ double    // [2, 4, 6, 8, 10]
[1, 2, 3, 4, 5] ~ square    // [1, 4, 9, 16, 25]
```

### Пример 4: Композиция функций

```wave
double ~ x ~ x * 2
addOne ~ x ~ x + 1
square ~ x ~ x * x

3 ~ double ~ addOne ~ square  // ((3 * 2) + 1)² = 49
```

### Пример 5: Функции высшего порядка

```wave
apply_twice ~ f ~ x ~ f(f(x))

inc ~ x ~ x + 1

apply_twice(inc, 5)  // inc(inc(5)) = 7
```

### Пример 6: Проверка простоты числа

```wave
is_prime_helper ~ n ~ d
  d * d > n ~ 1
  n % d = 0 ~ 0
  _ ~ is_prime_helper(n, d + 1)

is_prime ~ n
  n < 2 ~ 0
  n = 2 ~ 1
  _ ~ is_prime_helper(n, 2)

is_prime(17)  // Результат: 1 (истина)
```

---

## Встроенные функции

### Арифметика

#### `inc(x)`
Увеличивает число на 1.
```wave
inc(5)  // 6
```

#### `dec(x)`
Уменьшает число на 1.
```wave
dec(5)  // 4
```

#### `square(x)`
Возвращает квадрат числа.
```wave
square(5)  // 25
```

### Работа со списками

#### `head(list)`
Возвращает первый элемент списка.
```wave
head([1, 2, 3])  // 1
```

#### `tail(list)`
Возвращает список без первого элемента.
```wave
tail([1, 2, 3])  // [2, 3]
```

#### `sum(list)`
Возвращает сумму всех элементов списка.
```wave
sum([1, 2, 3, 4, 5])  // 15
```

### Ввод-вывод

#### `print(value)`
Выводит значение на экран.
```wave
print("Hello")
print(42)
print([1, 2, 3])
```

---

## Расширенные возможности

### Автоматическое применение (Map)

Когда функция применяется к списку, она автоматически применяется к каждому элементу:

```wave
square ~ x ~ x * x

[1, 2, 3, 4, 5] ~ square  // [1, 4, 9, 16, 25]
```

### Замыкания

Функции в Wave захватывают окружение, в котором они определены:

```wave
make_adder ~ n ~ x ~ x + n

add5 ~ make_adder(5)
add5(10)  // 15
```

### Композиция с разными стратегиями вычисления

```wave
double ~ x ~ x * 2
addTen ~ x ~ x + 10

// Строгая
5 ~~ double ~~ addTen  // 20

// Ленивая
5 ~> double ~> addTen  // 20

// Параллельная
[1, 2, 3] |~ double |~ addTen  // [12, 14, 16]
```

---

## Особенности реализации

### Реализованные функции

- ✅ Именованные переменные (`let`)
- ✅ Рекурсия
- ✅ Ленивое вычисление (частично)
- ✅ Функции
- ✅ Замыкания
- ✅ Библиотечные функции: ввод-вывод
- ✅ Списки / Последовательности
- ✅ Библиотечные функции: списки/последовательности

### Архитектура

Интерпретатор Wave состоит из следующих компонентов:

1. **Лексер** (`Lexer.fs`) — преобразует исходный код в токены
2. **Парсер** (`Parser.fs`) — строит AST из токенов
3. **AST** (`AST.fs`) — определение абстрактного синтаксического дерева
4. **Вычислитель** (`Evaluator.fs`) — интерпретирует AST
5. **Встроенные функции** (`Builtin.fs`) — стандартная библиотека
6. **REPL** (`REPL.fs`) — интерактивная среда

---

## Примеры использования

Смотрите папку `examples/` для примеров программ:

- `factorial.wave` — вычисление факториала
- `fibonacci.wave` — числа Фибоначчи
- `comprehensive.wave` — демонстрация всех возможностей
- `composition.wave` — примеры композиции функций
- `list_operations.wave` — работа со списками
- `higher_order.wave` — функции высшего порядка
- `advanced_composition.wave` — разные виды композиции
- `primes.wave` — проверка простоты чисел

---

## Лицензия и авторы

Проект разработан как учебное задание по функциональному программированию.

**Команда разработки:**

- **Участник 1 (Максимов Тимофей Степанович)** — Парсер и AST
- **Участник 2 (Попов Фома Алексеевич)** — Интерпретатор и REPL
- **Участник 3 (Пикулева Стефания Дмитриевна)** — Документация и визуальный отладчик

---

## Дополнительные ресурсы

- [Спецификация синтаксиса](SYNTAX.md)
- [Примеры программ](../examples/)
- [Исходный код на GitHub](https://github.com/yourusername/FP_WaveLang)



